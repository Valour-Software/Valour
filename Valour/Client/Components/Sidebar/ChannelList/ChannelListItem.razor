@using System.Text
@implements IDisposable
@inject ChannelListManager ListManager
@inject ClientCategoryManager CategoryManager
@inject ContextMenuService ContextMenuService
@inject ValourClient Client
@inject ChannelService ChannelService
@inject NotificationService NotificationService
@inject ChannelStateService ChannelStateService
@inject UnreadService UnreadService

<div
    style="margin-left: @((Depth - 1) * 18)px"
    class="channel-wrapper"
    draggable="true"
    depth="@Depth"

    @onclick:stopPropagation="true"
    @onclick="OnClick"

    @ondragstart:stopPropagation="true"
    @ondragstart="@OnDragStart"
    
    @ondrag:stopPropagation="true"
    @ondrag="@OnDrag"

    @ondrop:stopPropagation="true"
    @ondrop="@OnDropOn"

    @oncontextpress:stopPropagation="true"
    @oncontextpress="@OnContextMenu"

    @ondragleave:stopPropagation="true"
    @ondragleave="@OnDragLeave"

    @ondragend:stopPropagation="true"
    @ondragend="@OnDragEnd"
>
    <div class="channel-wrapper">

        @if (ListManager.DragOverId == Channel.Id &&
             ListManager.DragIsTop)
        {
            <div
                class="drop-line"
                @ondragenter:stopPropagation="true"
                ondragenter="return false;">
            </div>
        }
        <div
            class="@ChosenCss"
            id="@Channel.Id">

            <div class="channel-icon-holder">
                @{
                    var iconData = GetIconData();
                }

                <i class="channel-icon bi-@iconData.Icon" style="font-size: @iconData.Size" aria-label="@iconData.AltText"></i>

                @if (_notificationCount > 0)
                {
                    <p>@_notificationCount</p>
                }

                @if (IsPrivate)
                {
                    <img alt="Locked" class="lock-icon" src="_content/Valour.Client/media/channel-list/lock.svg"/>
                }
            </div>


            <p class="name">
                @Channel.Name
            </p>

        </div>
        @if (ListManager.DragOverId == Channel.Id &&
             !ListManager.DragIsTop)
        {
            <div
                class="drop-line"
                @ondragenter:stopPropagation="true"
                ondragenter="return false;">
            </div>
        }

        @if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
        {
            <div
                class="drop full"
                @ondragenter:stopPropagation="true"
                @ondragenter="@OnDragEnterBottom">
            </div>
        }
        else
        {
            <div
                class="drop top"
                @ondragenter:stopPropagation="true"
                @ondragenter="@OnDragEnterTop">
            </div>
            <div
                class="drop bottom"
                @ondragenter:stopPropagation="true"
                @ondragenter="@OnDragEnterBottom">
            </div>
        }
    </div>

    @*
    @if (_children is not null && _isOpen)
    {
        @if (_children.Count > 0)
        {
            <div class="sub-list" ondragover="event.preventDefault();">
                @foreach (var child in _children)
                {
                    <ChannelListItem @key="@($"{Channel.Id}-{child.Id}")"
                                     PlanetComponent="@PlanetComponent"
                                     ParentComponent="@this"
                                     Channel="@child"
                                     AllChannels="@AllChannels"
                                     Depth="@(Depth + 1)"/>
                }
            </div>
        }
        else
        {
            <!-- Makes it so you can insert into empty categories -->
            <div
                class="inner-drop @((ListManager.HighlightInner?.Channel?.Id ?? 0) == this.Channel.Id ? "highlight" : "")"
                @ondrop:stopPropagation="true"
                @ondrop="async () => await ListManager.OnItemDropIntoCategory(this)"
                @ondragenter:stopPropagation="true"
                @ondragenter="@OnDragEnterInnerDrop"
                @ondragleave="@Refresh">
                <span>Insert into @Channel.Name</span>
            </div>
        }
    }
    *@

</div>



@code {
    [Parameter]
    public PlanetListComponent PlanetComponent { get; set; }
    
    [Parameter]
    public ChannelListItem ParentComponent { get; set; }
    
    [Parameter]
    public SortedModelStore<Channel,long> AllChannels { get; set; }
    
    [Parameter]
    public Channel Channel { get; set; }
    
    private uint Depth => ChannelPosition.GetDepth(Channel.RawPosition);
    
    public Planet Planet { get; set; }
    
    private string ChosenCss
    {
        get
        {
            var css = "channel";

            if (WindowService.GlobalChatTabs.Any(x => x.Channel.Id == Channel.Id))
                css += " open";

            if (ListManager.DragOverId == Channel.Id)
                css += " drag-over";
            
            return css;
        }
    }
    
    public bool IsPrivate  { get; set; }
    public bool IsUnread { get; set; }
    
    private List<Channel> _children;
    private bool _isOpen;
    private int _notificationCount;
    
    protected override void OnInitialized()
    {
        // TODO: Deal with
        // ModelObserver<Channel>.AnyUpdated += OnChannelUpdate;
        // ModelObserver<Channel>.AnyDeleted += OnChannelDeletion;

        ChannelService.ChannelConnected += OnChannelConnectionChange;
        ChannelService.ChannelDisconnected += OnChannelConnectionChange;

        NotificationService.NotificationReceived += OnNotification;
        ChannelStateService.ChannelStateUpdated += OnChannelStateUpdate;
        ChannelStateService.UserChannelStateUpdated += OnUserChannelStateUpdate;

        Planet = PlanetComponent.Planet;

        _isOpen = CategoryManager.IsOpen(Channel);

        BuildChildren();
        DetermineNotifications();
        DetermineUnread();
    }

    private void OnContextMenu(ContextPressEventArgs e)
    {
        ContextMenuService.Root.OpenMenu<ChannelContextMenu>(e, new ChannelContextMenu.ChannelContextParams()
        {
            Channel = Channel
        });
    }

    private void BuildChildren()
    {
        if (Channel.ChannelType != ChannelTypeEnum.PlanetCategory)
            return;
        
        _children = AllChannels.Where(x => x.ParentId == Channel.Id).ToList();
        SortChildren();
    }
    
    private void SortChildren()
    {
        _children.Sort((x, y) =>
        {
            var a = x.RawPosition;
            var b = y.RawPosition;
            return a.CompareTo(b);
        });
    }
    
    private async Task OnClick()
    {
        ListManager.OnItemClickInCategory(this);

        // Chat channels
        if (ISharedChannel.ChatChannelTypes.Contains(Channel.ChannelType))
        {
            var newWindowContent = await ChatWindowComponent.GetDefaultContent(Channel);
            
            await WindowService.OpenWindowAtFocused(newWindowContent);
        }
        else if (ISharedChannel.VoiceChannelTypes.Contains(Channel.ChannelType))
        {
            await CallComponent.Instance.Initialize(Channel);
        }
        else if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
        {
            _isOpen = !_isOpen;
            CategoryManager.SetOpen(Channel, _isOpen);
            PlanetComponent.SetCategoryOpened(Channel.Id, !_isOpen);
        }
        
        Refresh();
    }
    
    private void DetermineUnread()
    {
        IsUnread = UnreadService.IsChannelUnread(Channel.PlanetId, Channel.Id);
    }

    private void DetermineNotifications()
    {
        _notificationCount = NotificationService.GetChannelNotifications(Channel.Id);
    }
    
    // Get local index
    public int GetIndex(Channel item)
    {
        return _children.FindIndex(x => x.Id == item.Id);
    }

    // Get children
    public List<Channel> GetChildren()
    {
        return _children;
    }
    
    #region Event Handlers
    
    private Task OnChannelUpdate(ModelUpdatedEvent<Channel> eventData)
    {
        var updated = eventData.Model;
        
        if (Channel.Id == updated.Id)
        {
            Refresh();
        }
        else if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
        {
            // If we contain the channel and its position or category changed we need to factor for that
            var old = _children.FirstOrDefault(x => x.Id == updated.Id);
            if (old != null)
            {
                // If removed from this category
                if (updated.ParentId != Channel.Id)
                {
                    _children.Remove(old);
                    BuildChildren();
                    Refresh();
                }
            }
            // In this case it was just added to this category
            else if (updated.ParentId == Channel.Id)
            {
                // Insert
                _children.Add(updated);
                // Resort
                BuildChildren();

                Console.WriteLine($"Inserted {updated.Name} into {Channel.Name}");

                Refresh();
            }
        }

        return Task.CompletedTask;
    }
    
    private Task OnChannelDeletion(Channel channel)
    {
        if (Channel.ChannelType != ChannelTypeEnum.PlanetCategory)
            return Task.CompletedTask;
        
        var old = _children.FirstOrDefault(x => x.Id == channel.Id);
        if (old is not null)
        {
             _children.Remove(old);
            BuildChildren();
            Refresh();
        }
        
        return Task.CompletedTask;
    }
    
    private Task OnUserChannelStateUpdate(UserChannelState state)
    {
        if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
        {
            var channel = _children.FirstOrDefault(x => x.Id == state.ChannelId);
            if (channel is null || channel.ParentId != Channel.Id)
                return Task.CompletedTask;
        }
        else
        {
            if (Channel.Id != state.ChannelId)
                return Task.CompletedTask;
        }
        
        DetermineUnread();
        Refresh();
        
        return Task.CompletedTask;
    }

    private Task OnChannelStateUpdate(ChannelStateUpdate state)
    {
        if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
        {
            var channel = _children.FirstOrDefault(x => x.Id == state.ChannelId);
            if (channel is null || channel.ParentId != Channel.Id)
                return Task.CompletedTask;
        }
        else
        {
            if (Channel.Id != state.ChannelId)
                return Task.CompletedTask;
        }
            
        DetermineUnread();
        Refresh();

        return Task.CompletedTask;
    }
    
    private Task OnChannelConnectionChange(Channel channel)
    {
        if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
            return Task.CompletedTask;
            
        Refresh();

        return Task.CompletedTask;
    }
    
    private Task OnNotification(Notification notification)
    {
        if (Channel.ChannelType == ChannelTypeEnum.PlanetCategory)
        {
            var channel = _children.FirstOrDefault(x => x.Id == notification.ChannelId);
            if (channel is null || channel.ParentId != Channel.Id)
                return Task.CompletedTask;
        }
        else
        {
            if (Channel.Id != notification.ChannelId)
                return Task.CompletedTask;
        }
        
        DetermineNotifications();
        Refresh();

        return Task.CompletedTask;
    }
    
    #endregion
    
    #region Icon Stuff

    private struct IconState
    {
        public bool Open;
        public bool Unread;
        public ChannelTypeEnum ChannelType;
        
        public IconState(bool open, bool unread, ChannelTypeEnum channelType)
        {
            Open = open;
            Unread = unread;
            ChannelType = channelType;
        }
        
        public override bool Equals(object obj)
        {
            return obj is IconState state &&
                   Open == state.Open &&
                   Unread == state.Unread &&
                   ChannelType == state.ChannelType;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(Open, Unread, ChannelType);
        }
    }

    private struct IconData
    {
        public string Icon;
        public string AltText;
        public string Size;
        
        public IconData(string icon, string altText, string size)
        {
            Icon = icon;
            AltText = altText;
            Size = size;
        }
    }

    private static readonly Dictionary<IconState, IconData> IconDataLookup = new()
    {
        // Planet chats (cant be open)
        { new IconState(false, false, ChannelTypeEnum.PlanetChat), new IconData("chat-left", "Chat channel", "12px")  },
        { new IconState(false, true, ChannelTypeEnum.PlanetChat), new IconData("chat-left-fill", "Chat channel with unread messages", "12px")  },
        
        // Planet categories
        { new IconState(true, false, ChannelTypeEnum.PlanetCategory), new IconData("caret-down", "Open category", "18px") },
        { new IconState(true, true, ChannelTypeEnum.PlanetCategory), new IconData("caret-down-fill", "Open category with unread messages", "18px") },
        { new IconState(false, false, ChannelTypeEnum.PlanetCategory), new IconData("caret-right", "Closed category", "18px") },
        { new IconState(false, true, ChannelTypeEnum.PlanetCategory), new IconData("caret-right-fill", "Closed category with unread messages", "18px") },
        
        // Planet voice
        { new IconState(false, false, ChannelTypeEnum.PlanetVoice), new IconData("volume-down", "Voice channel", "18px") },
        { new IconState(false, true, ChannelTypeEnum.PlanetVoice), new IconData("volume-down-fill", "Voice channel with unread messages", "18px") },
        
        // Direct chat
        { new IconState(false, false, ChannelTypeEnum.DirectChat), new IconData("chat-left", "Direct chat", "12px") },
        { new IconState(false, true, ChannelTypeEnum.DirectChat), new IconData("chat-left-fill", "Direct chat with unread messages", "12px") },
        
        // Direct voice
        { new IconState(false, false, ChannelTypeEnum.DirectVoice), new IconData("volume-down", "Direct voice", "18px") },
        { new IconState(false, true, ChannelTypeEnum.DirectVoice), new IconData("volume-down-fill", "Direct voice with unread messages", "18px") },
        
        // Group chat
        { new IconState(false, false, ChannelTypeEnum.GroupChat), new IconData("chat-left", "Group chat", "12px") },
        { new IconState(false, true, ChannelTypeEnum.GroupChat), new IconData("chat-left-fill", "Group chat with unread messages", "12px") },
        
        // Group voice
        { new IconState(false, false, ChannelTypeEnum.GroupVoice), new IconData("volume-down", "Group voice", "18px") },
        { new IconState(false, true, ChannelTypeEnum.GroupVoice), new IconData("volume-down-fill", "Group voice with unread messages", "18px") },
    };
    
    private static readonly IconData DefaultIconData = new IconData("question", "Unknown channel type", "15px");

    private IconData GetIconData()
    {
        var state = new IconState(_isOpen, IsUnread, Channel.ChannelType);
        return IconDataLookup.GetValueOrDefault(state, DefaultIconData); // Fallback to question mark icon
    }
    
    #endregion
    
    #region Drag and Drop
    
    private void OnDragEnterTop()
    {
        ListManager.OnDragEnterItem(Channel.Id, true);
        Refresh();
    }
    
    private void OnDragEnterBottom()
    {
        ListManager.OnDragEnterItem(Channel.Id, false);
        Refresh();
    }

    private async Task OnDrag(MouseEventArgs e)
    {
        await WindowTargetScanner.ScanAsync((float)e.ClientX, (float)e.ClientY);
    }
    
    private void OnDragStart()
    {
        ListManager.OnItemStartDragInCategory(this);
    }

    private async Task OnDragEnd(MouseEventArgs e)
    {
        ListManager.OnCancelDrag();
    }

    private void OnDragLeave()
    {
        Refresh();
    }

    private async Task OnDropOn()
    {
        await ListManager.OnItemDropOn(this);
        Refresh();
    }
    
    private void OnDragEnterInnerDrop()
    {
        ListManager.HighlightInner = this;
        Refresh();
    }
    
    #endregion
    
    #region Render controls
    
    private bool _render;
    
    public void Refresh()
    {
        _render = true;
        StateHasChanged();
    }
    
    protected override bool ShouldRender() => _render;

    protected override void OnAfterRender(bool firstRender)
    {
        _render = false;
    }
    
    #endregion
    
    public void Dispose()
    {
        //ModelObserver<Channel>.AnyUpdated -= OnChannelUpdate;
        //ModelObserver<Channel>.AnyDeleted -= OnChannelDeletion;
        
        NotificationService.NotificationReceived -= OnNotification;
        ChannelStateService.ChannelStateUpdated -= OnChannelStateUpdate;
        ChannelStateService.UserChannelStateUpdated -= OnUserChannelStateUpdate;
        
        ChannelService.ChannelConnected -= OnChannelConnectionChange;
        ChannelService.ChannelDisconnected -= OnChannelConnectionChange;
    }
}