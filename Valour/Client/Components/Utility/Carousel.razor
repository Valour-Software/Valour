@typeparam TComponent

<div class="carousel-container" style="min-height: @(Height)px">
    <button class="carousel-nav prev @(CanScrollLeft ? "" : "disabled")" @onclick="ScrollLeft" aria-label="Previous items">
        <i class="bi bi-chevron-left"></i>
    </button>

    <div class="carousel-viewport" @ref="_viewportElement">
        <div class="carousel-track" style="transform: translateX(@($"{-_currentOffset}px"))">
            @for (var i = 0; i < _loadedItems.Count; i++)
            {
                var index = i;
                <div class="carousel-item" @key="index">
                    <DynamicComponent Type="@typeof(TComponent)" Parameters="@_loadedItems[index]" />
                </div>
            }
            
            @if (_isLoading)
            {
                <div class="carousel-item loading">
                    <div class="loading-indicator"></div>
                </div>
            }
        </div>
    </div>

    <button class="carousel-nav next  @(CanScrollRight ? "" :"disabled")" @onclick="ScrollRight" aria-label="Next items">
        <i class="bi bi-chevron-right"></i>
    </button>
</div>


@code {
    [Parameter]
    public int Height { get; set; } = 350; // Default height (300px)
    
    [Parameter]
    public int ItemWidth { get; set; } = 216; // Default item width (200px + 16px margin)
    
    [Parameter]
    public int TotalItems { get; set; }
    
    [Parameter]
    public int VisibleItems { get; set; } = 3;
    
    [Parameter]
    public int InitialLoadCount { get; set; } = 8;
    
    [Parameter]
    public int PreloadThreshold { get; set; } = 3;
    
    [Parameter]
    public Func<int, Task<Dictionary<string, object>>> GetItem { get; set; }
    
    [Parameter]
    public EventCallback OnSwipe { get; set; }

    [Parameter] public bool AutoScroll { get; set; } = true;
    
    [Parameter]
    public int AutoScrollInterval { get; set; } = 5000;
    
    private ElementReference _viewportElement;
    private List<Dictionary<string, object>> _loadedItems = new();
    private int _currentIndex = 0;
    private int _currentOffset = 0;
    private bool _isLoading = false;
    private Timer _autoScrollTimer;
    private bool _scrollRight = true;
    private bool CanScrollRight => _currentIndex <= (_loadedItems.Count - VisibleItems);
    private bool CanScrollLeft => _currentIndex > 0;
    
    
    
    protected override async Task OnInitializedAsync()
    {
        await LoadInitialItems();
        
        if (AutoScroll)
        {
            StartAutoScroll();
        }
    }
    
    protected override async Task OnParametersSetAsync()
    {
        if (AutoScroll)
        {
            StartAutoScroll();
        }
        else
        {
            _autoScrollTimer?.Dispose();
            _autoScrollTimer = null;
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Option to get the actual item width from DOM if needed
            // var width = await JSRuntime.InvokeAsync<double>("getCarouselItemWidth");
            // if (width > 0) _itemWidth = (int)width;
        }
    }
    

    private async Task LoadInitialItems()
    {
        _isLoading = true;
        for (int i = 0; i < TotalItems; i++)
        {
            var item = await GetItem(i);
            if (item != null)
                _loadedItems.Add(item);
            else
                break;
        }
        _isLoading = false;
    }


    private async Task LoadMoreItems()
    {
        if (_isLoading || _loadedItems.Count >= TotalItems)
            return;

        _isLoading = true;
        StateHasChanged();

        int startIndex = _loadedItems.Count;
        int count = Math.Min(InitialLoadCount, TotalItems - startIndex);

        for (int i = 0; i < count; i++)
        {
            if (startIndex + i >= TotalItems)
                break;
            var item = await GetItem(startIndex + i);
            if (item != null)
                _loadedItems.Add(item);
            else
                break;
        }

        _isLoading = false;
        StateHasChanged();
    }
    
    private void StartAutoScroll()
    {
        _autoScrollTimer?.Dispose();
        _autoScrollTimer = new Timer(TimerCallback, null, AutoScrollInterval, AutoScrollInterval);
    }
    
    private void TimerCallback(object state)
    {
        _ = InvokeAsync(async () => await AutoScrollStep());
    }
    
    
    private async Task AutoScrollStep()
    {
        try
        {
            if (_scrollRight)
            {
                if (!CanScrollRight)
                {
                    _scrollRight = false;
                    await ScrollLeft();
                }
                else
                {
                    await ScrollRight();
                }
            }
            else
            {
                if (!CanScrollLeft)
                {
                    _scrollRight = true;
                    await ScrollRight();
                }
                else
                {
                    await ScrollLeft();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Carousel] Error en AutoScrollStep: {ex.Message}");
        }
    }
    
    private async Task ScrollLeft()
    {
        if (!CanScrollLeft) return;
        
        _currentIndex = Math.Max(0, _currentIndex - 1);
        _currentOffset = _currentIndex * ItemWidth;
        
        await OnSwipe.InvokeAsync();
        StateHasChanged();
    }
    
    private async Task ScrollRight()
    {
        if (_currentIndex > (_loadedItems.Count - VisibleItems)) return;

        _currentIndex++;
        _currentOffset = _currentIndex * ItemWidth;

        if (_currentIndex + VisibleItems > _loadedItems.Count && _loadedItems.Count < TotalItems)
            await LoadMoreItems();

        await OnSwipe.InvokeAsync();
        StateHasChanged();
    }

    
    public async Task Reset()
    {
        _loadedItems.Clear();
        _currentIndex = 0;
        _currentOffset = 0;
        _isLoading = false;
        await LoadInitialItems();
        StateHasChanged();
    }

    
    public void Dispose()
    {
        _autoScrollTimer?.Dispose();
    }
}