@implements IDisposable
@inject NavigationManager NavManager
@inject NotificationService NotificationService

<div class="quick-notif">
    @foreach (var notif in _showing.ToList())
    {
        <TooltipTrigger Position="left">
            <ChildContent>
                <div
                    class="item @(notif.Animating ? "animate" : "")"
                    @key="@notif.Notification.Id"
                    @onmouseenter="@(() => OnMouseEnter(notif))"
                    @onmousedown="@((e) => OnMouseDown(e, notif))"
                >
                    <img alt="Notification: @notif.Notification.Title" class="icon" src="@notif.ImageUrl" @onerror="@(() => OnImageError(notif))" />
                </div>
            </ChildContent>
            <TooltipContent>
                <span>@notif.Notification.Title</span>
            </TooltipContent>
        </TooltipTrigger>
    }
</div>

@code {
    
    const string FailedImageUrl = "_content/Valour.Client/media/logo/logo-128.webp";
    
    private class QuickNotif
    {
        public Notification Notification { get; set; }
        public bool Animating { get; set; }
        public string ImageUrl { get; set; }
    }
    
    private List<QuickNotif> _showing = new List<QuickNotif>();

    protected override void OnInitialized()
    {
        NotificationService.NotificationReceived += NotificationHandler;
        NotificationService.NotificationsCleared += NotificationsClearedHandler;
    }

    private void OnImageError(QuickNotif notif)
    {
        notif.ImageUrl = FailedImageUrl;
        StateHasChanged();
    }

    void IDisposable.Dispose()
    {
        NotificationService.NotificationReceived -= NotificationHandler;
        NotificationService.NotificationsCleared -= NotificationsClearedHandler;
    }
    
    private Task NotificationsClearedHandler()
    {
        return InvokeAsync(() =>
        {
            _showing.Clear();
            StateHasChanged();
        });
    }

    private Task NotificationHandler(Notification notification)
    {
        return InvokeAsync(() =>
        {
            bool render = false;

            if (notification.TimeRead is null)
            {
                _showing.Add(new QuickNotif()
                {
                    Notification = notification,
                    Animating = true,
                    ImageUrl = notification.ImageUrl ?? FailedImageUrl
                });
                render = true;
            }
            else
            {
                var removed = _showing.RemoveAll(x => x.Notification.Id == notification.Id);
                if (removed > 0)
                    render = true;
            }

            if (render)
                StateHasChanged();
        });
    }

    private void OnMouseEnter(QuickNotif notif)
    {
        if (notif.Animating)
        {
            notif.Animating = false;
            StateHasChanged();
        }
    }

    private async Task OnMouseDown(MouseEventArgs e, QuickNotif notif)
    {
        if (e.Button == 2)
        {
            await NotificationService.MarkNotificationRead(notif.Notification, true);
        }
        else if (e.Button == 0)
        {
            await NotificationNavigator.NavigateTo(notif.Notification);
        }
    }
}