@inherits WindowContentComponent<Channel>
@implements IAsyncDisposable
@inject IJSRuntime JsRuntime
@inject ValourClient Client
@inject UnreadService UnreadService
@using Valour.Sdk.Nodes
@using Channel = Valour.Sdk.Models.Channel

@if (_loading)
{
    <Loading Title="Loading chat..." Spin="@true" />
}
else
{
    <ChatHeaderComponent Channel="@Channel" ChatComponent="@this" />
    <div class="chat-member-wrapper">
        <div style="width: 100%; overflow: hidden" @onmouseleave="@OnMouseLeaveMessageArea">
            <div @ref="@MessageWrapperEl" class="chat-holder mt-auto">
                <!-- Pushes messages to bottom -->
                <div class="pusher"></div>

                <!-- Actual messages -->
                @MessagesFragment

                <div class="anchor"></div>
            </div>
            <RadialPalette @ref="@_hoverMenu"
                           OptionSize="60"
                           Scale="0.5"
                           Radius="75"
                           AnimationDelayStep="0.02"/>

            <ControlledRenderWrapper @ref="@_reactionSelectorRenderWrapper">
                <div class="reaction-selector-wrapper" style="bottom: @(_reactionSelectorTop); right: @(_reactionSelectorLeft);">
                    <EmojiMart @ref="@_reactionSelector" EmojiSet="twitter" StartShown="false" OnClickOutside="@OnClickOutsideReactionPicker" OnEmojiClick="@OnReactionSelectedAsync"/>
                </div>
            </ControlledRenderWrapper>
        </div>
        <MemberListComponent @ref="@MemberListComponent" Channel="@Channel"/>
    </div>
}

<InputComponent @ref="@InputComponent" ChatComponent="@this" />


@code {

    public List<RadialPalette.Option> GetHoverMenuOptions()
    {
        var options = new List<RadialPalette.Option>();

        var message = _hoverMenuMessage?.ParamData?.Message;

        if (message is null)
            return [];
        
        // If owner, add edit
        if (Client.Me.Id == message.AuthorUserId)
        {
            var edit = new RadialPalette.Option()
            {
                Id = "edit",
                Icon = "pencil",
                Name = "Edit",
                Action = async (_) => await OpenEditMode(_hoverMenuMessage)
            };
            
            options.Add(edit);
        }
        else
        {
            // Add report
            var report = new RadialPalette.Option()
            {
                Id = "report",
                Icon = "flag-fill",
                Name = "Report",
                Color = "var(--p-red)",
                Action = (_) =>
                {
                    ShowReportModal(message);
                    return Task.CompletedTask;
                }
            };
            
            options.Add(report);
        }

        if (Client.Me.Id == message.Id || 
            ChannelPermissions.GetPermissionState(ChatChannelPermissions.ManageMessages) == PermissionState.True)
        {
            var delete = new RadialPalette.Option()
            {
                Id = "delete",
                Icon = "bi bi-trash",
                Name = "Delete",
                Color = "var(--p-red)",
                Action = (_) =>
                {
                    ShowMessageDeleteModal(message);
                    return Task.CompletedTask;
                }
            };
            
            options.Add(delete);
        }
        
        // Always add reaction option
        var reaction = new RadialPalette.Option()
        {
            Id = "reaction",
            Icon = "emoji-smile",
            Name = "React",
            Action = (e) =>
            {
                _currentlyReactingMessage = message;
                
                // Reposition
                _reactionSelectorLeft = (BrowserUtils.WindowDimensions.Width - e.ClientX) + "px";
                _reactionSelectorTop = Math.Min(BrowserUtils.WindowDimensions.Height - e.ClientY, 350) + "px";
                
                // Re-render JUST the emoji selector
                _reactionSelectorRenderWrapper.ReRender();
                
                _reactionSelector.ToggleVisible();
                
                // Close hover menu
                _hoverMenu.SetVisible(false);
                
                return Task.CompletedTask;
            }
        };
        
        // Always add three most recent reactions
        var reaction1 = new RadialPalette.Option()
        {
            Emoji = "😀",
            Name = "😀",
            Action = async (_) =>
            {
                await message.AddReactionAsync("😀");
            }
        };
        
        var reaction2 = new RadialPalette.Option()
        {
            Emoji = "💀",
            Name = "💀",
            Action = async (_) =>
            {
                await message.AddReactionAsync("💀");
            }
        };
        
        var reaction3 = new RadialPalette.Option()
        {
            Emoji = "🚀",
            Name = "🚀",
            Action = async (_) =>
            {
                await message.AddReactionAsync("🚀");
            }
        };
        
        options.Add(reaction);
        options.Add(reaction1);
        options.Add(reaction2);
        options.Add(reaction3);
        
        return options;
    }
    
    /* Used for palette */
    private RadialPalette _hoverMenu;
    private MessageComponent _hoverMenuMessage;
    private string _hoverMenuTop;
    private string _hoverMenuRight;
    
    private EmojiMart _reactionSelector;
    private ControlledRenderWrapper _reactionSelectorRenderWrapper;
    private Message _currentlyReactingMessage;
    private string _reactionSelectorLeft;
    private string _reactionSelectorTop;
    
    private bool _loading = true;

    public Channel Channel;
    public PermissionsNode ChannelPermissions { get; set; }
    
    // Virtual window constants and state
    // TrimThreshold: how many messages before we actually cut.
    // TargetMessages: how many to keep after trimming.
    // The gap between them prevents trim-on-every-load bouncing.
    private const int TrimThreshold = 360;
    private const int TargetMessages = 120;
    private bool _isCaughtUp = true;
    private bool _loadingForward = false;

    /// <summary>
    /// The message ID to highlight (e.g. from notification navigation). 0 = none.
    /// </summary>
    public long HighlightedMessageId { get; set; }

    /// <summary>
    /// When true, suppresses auto-scroll behaviors (ShiftScrollPosition, ScrollToBottom)
    /// so that LoadAroundMessageAsync / ScrollToMessage isn't fought by loading messages.
    /// </summary>
    public bool SuppressAutoScroll { get; set; }

    // Stores for messages (Always initialized so don't bother null checking)
    // TODO: Replace with CircularBuffer
    public List<Message> DisplayedMessages { get; set; } = new();
    public List<Message> QueuedMessages { get; set; } = new();
    public List<MessageComponent> RenderedMessages { get; set; } = new();

    // Interop references
    public ElementReference MessageWrapperEl;
    private DotNetObjectReference<ChatWindowComponent> _thisRef;
    private IJSObjectReference _jsModule;
    private IJSObjectReference _jsService;
    
    // Child references
    public InputComponent InputComponent;
    public MemberListComponent MemberListComponent;
    
    // Used for locking channel connection while window is open
    private readonly string _instanceId = Guid.NewGuid().ToString();
    private string WindowChannelKey => _instanceId;

    // Runs when page is initialized
    protected override void OnInitialized()
    {
        Channel = Data;

        if (Channel is null)
        {
            Client.Logger.Log<ChatWindowComponent>("Channel is null, cannot initialize.", "red");
            return;
        }
        
        _thisRef = DotNetObjectReference.Create(this);
        
        Client.Logger.Log<ChatWindowComponent>("Initializing channel window component.", "cyan");
        
        Client.NodeService.NodeReconnected += OnNodeReconnect;
        BrowserUtils.Focused += OnBrowserFocused;
        
        Channel.MessageReceived += OnReceiveMessage;
        Channel.MessageEdited += OnReceiveMessageEdit;
        Channel.MessageDeleted += OnDeleteMessage;
        
        WindowCtx.Tab.OnStartFloating += OnStartFloating;
    }

    protected override async Task OnInitializedAsync()
    {
        if (TutorialComponent.Instance is not null)
            await TutorialComponent.Instance.ShowChatTutorial();
    }

    private async Task OnReactionSelectedAsync(EmojiClickEvent e)
    {
        // toggle visible
        _reactionSelector.ToggleVisible();
        
        if (_currentlyReactingMessage is null) return;
        await _currentlyReactingMessage.AddReactionAsync(e.Native);
    }
    
    private Task OnClickOutsideReactionPicker(OutsidePickerClickEvent e)
    {
        if (e.Target.ToLower().Contains("option"))
            return Task.CompletedTask;
        
        _reactionSelector.ToggleVisible();
        return Task.CompletedTask;
    }

    private void ShowMessageDeleteModal(Message message)
    {
        var desc = message.Content.Length > 32 ? message.Content.Substring(0, 32) + "..." : message.Content;
        
        var data = new ConfirmModalComponent.ModalParams("Delete message?", desc, "Delete", "Cancel",
            async () =>
            {
                await message.DeleteAsync();
            },
            () => Task.CompletedTask
        );

        ModalRoot.Instance.OpenModal<ConfirmModalComponent>(data);
    }

    private void ShowReportModal(Message message)
    {
        var data = new ReportModalComponent.ModalParams()
        {
            Report = new Report()
            {
                ReportingUserId = Client.Me.Id,
                MessageId = message.Id,
                ChannelId = message.ChannelId,
                PlanetId = message.PlanetId
            }
        };
        
        ModalRoot.Instance.OpenModal<ReportModalComponent>(data);
    }
    
    public async Task SetupNewChannelAsync()
    {
        if (Channel is null)
        {
            Client.Logger.Log<ChatWindowComponent>("Cannot set up chat window because channel data is null.", "red");
            _loading = false;
            ReRender();
            return;
        }

        if (!_loading)
        {
            _loading = true;
            ReRender();
        }

        try
        {
            var openResult = await Channel.OpenWithResult(WindowChannelKey);
            if (!openResult.Success)
                throw new Exception($"Failed to open channel connection: {openResult.Message}");

            if (Channel.Node is null)
                throw new Exception("Channel node is unavailable after opening connection.");

            // Planet stuff
            if (Channel.PlanetId is not null)
            {
                await Channel.Planet.EnsureReadyAsync();
                var myMember = Channel.Planet.MyMember;
                if (myMember is null)
                {
                    throw new Exception("Planet membership was not found while setting up this channel.");
                }

                Channel.Planet.Deleted += OnPlanetDeleted;
                myMember.Deleted += OnSelfMemberDeleted;
                ChannelPermissions = await Channel.GetFlattenedPermissionsAsync(myMember.Id);
            }

            Channel.Updated += OnChatChannelUpdate;

            ClearMessages(false);
            _isCaughtUp = true;
            _loadingForward = false;

            // Check if we should load around a specific message (e.g. from notification)
            var targetMessageId = (WindowCtx as Content)?.TargetMessageId;
            if (targetMessageId is not null && targetMessageId.Value != 0)
            {
                await LoadAroundMessageAsync(targetMessageId.Value);
                // Clear so re-setup doesn't re-navigate
                ((Content)WindowCtx).TargetMessageId = null;
            }
            else
            {
                await LoadRecentMessages(64);
            }

            await Channel.UpdateUserState(DateTime.UtcNow);
        }
        catch (Exception e)
        {
            Client.Logger.Log<ChatWindowComponent>($"Error setting up channel: {e}", "red");
        }

        _loading = false;

        if (InputComponent is not null)
            await InputComponent.NotifyChannelLoadedAsync();

        ReRender();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Channel is null)
        {
            await base.OnAfterRenderAsync(firstRender);
            return;
        }

        if (firstRender)
        {
            await SetupNewChannelAsync();
            _jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/Valour.Client/Components/Windows/ChannelWindows/ChatWindowComponent.razor.js");
            _jsService = await _jsModule.InvokeAsync<IJSObjectReference>("init", _thisRef, MessageWrapperEl);

            await ScrollToBottom(true);
        }
        
        UnreadService.MarkChannelRead(Channel.PlanetId, Channel.Id);
        
        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task OpenEditMode(MessageComponent message)
    {
        await InputComponent.OnBeginEdit(message, message.ParamData.Message);
    }

    public async Task CloseEditMode(bool cancel = false)
    {
        await InputComponent.OnStopEdit(cancel);
    }
    
    public async Task OnChatChannelUpdate(ModelUpdatedEvent<Channel> eventData)
    {
        await ReRender();
    }

    public virtual async Task OnReceiveMessage(Message message)
    {
        // Ignore messages not meant for this channel
        if (message.ChannelId != Channel.Id)
            return;

        // Skip real-time messages when we're scrolled away from the present —
        // they'll be fetched via forward loading when the user scrolls back down.
        if (!_isCaughtUp)
            return;

        await InvokeAsync(async () =>
        {
            // TODO: Eventually move to message render with a specific time of message sent
            UnreadService.MarkChannelRead(Channel.PlanetId, Channel.Id);

            await AddMessage(message);
            InputComponent.PreviewMessageComponent.SetLast(GetLastMessage());
            InputComponent.PreviewMessageComponent.CheckMinimal();
            await InputComponent.PreviewMessageComponent.ReRender();
        });
    }
    
    public virtual async Task OnReceiveMessageEdit(Message message)
    {
        // Ignore messages not meant for this channel
        if (message.ChannelId != Channel.Id)
            return;

        await InvokeAsync(async () =>
        {
            foreach (var messageComponent in RenderedMessages)
            {
                if (messageComponent.ParamData.Message.Id == message.Id)
                {
                    var msg = messageComponent.ParamData.Message;

                    msg.EditedTime = DateTime.UtcNow;
                    msg.Content = message.Content;
                    msg.AttachmentsData = message.AttachmentsData;
                    msg.MentionsData = message.MentionsData;

                    if (messageComponent.Edit)
                    {
                        await messageComponent.CloseEditMode();
                    }

                    messageComponent.BuildMessage(true);
                }
            }
        });
    }

    public async Task OnClickWindow()
    {
        await WindowCtx.Tab.NotifyFocused();
    }
    
    public async Task OnStartFloating()
    {
        await ScrollToBottom();
    }

    public Task OnPlanetDeleted()
    {
        return WindowCtx.Tab.SetContent(HomeWindowComponent.DefaultContent);
    }

    public Task OnSelfMemberDeleted()
    {
        return WindowCtx.Tab.SetContent(HomeWindowComponent.DefaultContent);
    }
    
    public async Task<List<PlanetMember>> GetLastChatMembers(int count)
    {
        // Not applicable for non-planet channels
        if (Channel.PlanetId is null)
            return new List<PlanetMember>();
        
        var lastMessages = DisplayedMessages.TakeLast(20).Reverse();
        List<PlanetMember> chatters = new();

        foreach (var message in lastMessages)
        {
            var member = await message.FetchAuthorMemberAsync();
            if (!chatters.Contains(member))
                chatters.Add(member);
        }

        return chatters;
    }
    
    ///////////////////////
    // Message Rendering //
    ///////////////////////

    private HashSet<long> _messageSet = new();
    
    private RenderFragment MessagesFragment => builder =>
    {
        _messageSet.Clear();

        Message lastMessage = null;

        // Displayed messages
        foreach (var message in DisplayedMessages)
        {
            if (_messageSet.Contains(message.Id))
            {
                Console.WriteLine("[SEVERE] Duplicate message detected: " + message.Id);
                continue;
            }

            var messageParams = new MessageComponent.Params()
            {
                ChatComponent = this,
                Message = message,
                IsInnerReply = false,
                LastMessage = lastMessage,
                Ghost = false,
            };

            builder.OpenComponent<MessageComponent>(0);
            builder.AddAttribute(1, "ParamData", messageParams);
            builder.SetKey(message.Id);
            builder.CloseComponent();

            lastMessage = message;

            _messageSet.Add(message.Id);
        }

        // Queued (ghost) messages — ghosts are removed from this list
        // before rendering when their real message arrives, so no
        // fingerprint-skip logic is needed here.
        foreach (var message in QueuedMessages)
        {
            var messageParams = new MessageComponent.Params()
            {
                ChatComponent = this,
                Message = message,
                IsInnerReply = false,
                LastMessage = lastMessage,
                Ghost = true,
            };

            builder.OpenComponent<MessageComponent>(0);
            builder.AddAttribute(1, "ParamData", messageParams);
            builder.SetKey($"q-{message.Fingerprint}");
            builder.CloseComponent();

            lastMessage = message;
        }

    };
    
    //////////////////////
    // Message Handling //
    //////////////////////
    
    public async Task LoadRecentMessages(int count)
    {
        var messages = await Channel.GetLastMessagesAsync(count);
        await AddMessages(messages, true, true);
    }

    /// <summary>
    /// Loads messages around a target message and highlights it.
    /// Used for notification click-through and search result navigation.
    /// </summary>
    public async Task LoadAroundMessageAsync(long messageId)
    {
        ClearMessages(false);
        _isCaughtUp = false;
        _loadingForward = false;
        HighlightedMessageId = messageId;
        SuppressAutoScroll = true;

        // Fetch messages up to and including the target (Id < messageId+1 gets Id <= messageId)
        var before = await Channel.GetMessagesAsync(messageId + 1, 32);
        // Fetch messages after the target
        var after = await Channel.GetMessagesAfterAsync(messageId, 32);

        var combined = new List<Message>();
        if (before is not null)
            combined.AddRange(before);
        if (after is not null)
            combined.AddRange(after);

        if (combined.Count == 0)
        {
            // Target not found — fall back to recent messages
            _isCaughtUp = true;
            HighlightedMessageId = 0;
            SuppressAutoScroll = false;
            await LoadRecentMessages(64);
            return;
        }

        await AddMessages(combined, render: false, scroll: false);

        // If we got fewer than requested after, we're caught up to the present
        if (after is null || after.Count < 32)
            _isCaughtUp = true;

        ReRender();

        // Scroll to the target message after render
        await ScrollToMessage(messageId);

        // Keep suppressing auto-scroll while messages finish loading
        // (avatars, embeds, etc. trigger ShiftScrollPosition which would
        // fight our position). Release after content has settled.
        _ = ReleaseSuppressAfterDelay();

        // Auto-clear highlight after a delay
        _ = ClearHighlightAfterDelay();
    }

    private async Task ReleaseSuppressAfterDelay()
    {
        await Task.Delay(1500);
        SuppressAutoScroll = false;
    }

    private async Task ClearHighlightAfterDelay()
    {
        await Task.Delay(3000);
        HighlightedMessageId = 0;
        await InvokeAsync(ReRender);
    }

    public async Task AddQueuedMessage(Message message)
    {
        // If not caught up, snap back to live mode before sending
        if (!_isCaughtUp)
        {
            _isCaughtUp = true;
            ClearMessages(false);
            await LoadRecentMessages(64);
        }

        // Guard against duplicate if already pre-queued (e.g. from OnChatboxSubmit)
        if (!QueuedMessages.Contains(message))
            QueuedMessages.Add(message);

        await ReRender();
        await ScrollToBottom();
    }

    public void RemoveQueuedMessage(string fingerprint)
    {
        
        var queued = QueuedMessages.FirstOrDefault(x => x.Fingerprint == fingerprint);
        if (queued != null)
        {
            //Console.WriteLine("Removed Queued Message");
            QueuedMessages.Remove(queued);
            ReRender();
        }
    }

    public void RemoveErrorMessage()
    {
        var error = DisplayedMessages.FirstOrDefault(x => x.Id == long.MaxValue);
        if (error != null) { 
            //Console.WriteLine("Removed error message");
            DisplayedMessages.Remove(error); 
            ReRender();
        }
    }
    
    public void ClearMessages(bool render = true)
    {
        DisplayedMessages.Clear();
        QueuedMessages.Clear();
        RenderedMessages.Clear();
        
        if (render)
            ReRender();
    }
    
    public Message GetLastMessage()
    {
        return QueuedMessages.LastOrDefault() ?? DisplayedMessages.LastOrDefault();
    }
    
    public async Task AddMessages(List<Message> messages, bool render = true, bool scroll = false)
    {
        if (messages is null || messages.Count == 0)
            return;

        var existingIds = DisplayedMessages.Select(x => x.Id).ToHashSet();
        var uniqueNew = new List<Message>(messages.Count);

        foreach (var msg in messages)
        {
            if (msg is null)
                continue;

            if (existingIds.Add(msg.Id))
                uniqueNew.Add(msg);
        }

        if (uniqueNew.Count == 0)
            return;

        DisplayedMessages.AddRange(uniqueNew);
        DisplayedMessages.Sort(MessageComparerInstance);

        if (render)
        {
            await ReRender();
        }

        if (scroll)
        {
            await ScrollToBottom();
        }

        InputComponent.Refresh();
    }

    public void InsertMessages(int position, List<Message> messages, bool render = true)
    {
        DisplayedMessages.InsertRange(position, messages);

        if (render)
        {
            ReRender();
        }
    }

    public async Task AddMessage(Message message, bool render = true)
    {
        //Get current window scroll pos
        var atBottom = await _jsService.InvokeAsync<bool>("isAtBottom");

        // Remove the matching ghost BEFORE rendering so the ghost removal and
        // real message insertion appear in the same render frame with no gap.
        if (!string.IsNullOrEmpty(message.Fingerprint))
            QueuedMessages.RemoveAll(x => x.Fingerprint == message.Fingerprint);

        DisplayedMessages.Add(message);

        // check if there's too many messages
        if (atBottom && DisplayedMessages.Count > TrimThreshold)
        {
            DisplayedMessages.RemoveRange(0, DisplayedMessages.Count - TargetMessages);
        }

        // Flag for UI refresh
        if (render)
        {
            await ReRender();
        }

        await ScrollToBottom();
    }
    
    public void ToggleMembersList()
    {
        MemberListComponent.ToggleVisible();
    }
    
    /* This is called by the MessageComponent when it is rendered */
    public void AddRenderedMessage(MessageComponent message)
    {
        RenderedMessages.Add(message);
    }

    /* This is called by the MessageComponent when it is disposed */
    public void RemoveRenderedMessage(MessageComponent message)
    {
        RenderedMessages.Remove(message);
    }
    
    // Used for sorting messages
    private static readonly MessageComparer MessageComparerInstance = new();

    private class MessageComparer : IComparer<Message>
    {
        public int Compare(Message a, Message b)
        {
            if (ReferenceEquals(a, b))
                return 0;
            if (a is null)
                return -1;
            if (b is null)
                return 1;

            return a.Id.CompareTo(b.Id);
        }
    }
    
    // Events
    
    public async Task OnDeleteMessage(Message message)
    {
        await InvokeAsync(async () =>
        {
            DisplayedMessages.RemoveAll(x => x.Id == message.Id);
            QueuedMessages.RemoveAll(x => x.Id == message.Id);

            var nextMessage = RenderedMessages.FirstOrDefault(x => x.ParamData.Message.Id > message.Id);
            if (nextMessage != null){
                var lastMessage = RenderedMessages
                    .OrderByDescending(x => x.ParamData.Message.Id)
                    .FirstOrDefault(x => x.ParamData.Message.Id < message.Id);

                if (lastMessage is not null)
                    nextMessage.SetLast(lastMessage.ParamData.Message);

                nextMessage.RefreshMessage();
                await nextMessage.ReRender();
            }

            await ReRender();
        });
    }

    /////////////////////
    // JS Interop Zone //
    /////////////////////

    public ValueTask ScrollToBottom(bool force = false)
    {
        if (SuppressAutoScroll)
            return ValueTask.CompletedTask;

        if (_jsService is not null)
            return _jsService.InvokeVoidAsync("scrollToBottom", force);

        return ValueTask.CompletedTask;
    }

    public ValueTask ScrollToBottomAnimated() => _jsService.InvokeVoidAsync("scrollToBottomAnimated");

    public ValueTask UpdateScrollPosition() => _jsService.InvokeVoidAsync("updateScrollPosition");

    public ValueTask ScaleScrollPosition() => _jsService.InvokeVoidAsync("scaleScrollPosition");

    public ValueTask ShiftScrollPosition(float amount)
    {
        if (SuppressAutoScroll)
            return ValueTask.CompletedTask;

        return _jsService.InvokeVoidAsync("shiftScrollPosition", amount);
    }

    public ValueTask ScrollToMessage(long messageId) => _jsService.InvokeVoidAsync("scrollToMessage", $"m-{Channel.Id}-{messageId}");

    [JSInvokable("OnScrollBottomInvoke")]
    public async Task OnScrollBottom()
    {
        if (_isCaughtUp || _loadingForward)
            return;

        if (DisplayedMessages == null || DisplayedMessages.Count == 0)
            return;

        _loadingForward = true;

        try
        {
            var lastId = DisplayedMessages[^1].Id;

            var messages = await Channel.GetMessagesAfterAsync(lastId, 64);

            if (messages is null || messages.Count == 0)
            {
                _isCaughtUp = true;
                return;
            }

            // Step 1: Append newer messages below viewport.
            // Content below doesn't affect scroll position, so no adjustment needed.
            DisplayedMessages.AddRange(messages);
            ReRender();

            // Step 2: Trim from the top if we exceed the cap.
            // ScaleScrollPosition correctly handles removal-from-above:
            // newHeight < oldHeight → scrollTop decreases by the removed height.
            if (DisplayedMessages.Count > TrimThreshold)
            {
                var excess = DisplayedMessages.Count - TargetMessages;
                DisplayedMessages.RemoveRange(0, excess);

                await UpdateScrollPosition();
                ReRender();
                await ScaleScrollPosition();
            }

            // If fewer than requested, we've reached the present
            if (messages.Count < 64)
            {
                _isCaughtUp = true;
            }
        }
        finally
        {
            _loadingForward = false;
        }
    }

    [JSInvokable("OnDebouncedScroll")]
    public void OnDebouncedScroll()
    {
        //_hoverMenu.SetVisible(false);
    }
    

    [JSInvokable("OnScrollTopInvoke")]
    public async Task OnScrollTop()
    {
        if (DisplayedMessages == null ||
            DisplayedMessages.Count == 0)
        {
            return;
        }

        var firstId = DisplayedMessages[0].Id;

        Client.Logger.Log<ChatWindowComponent>($"Fetching older messages from id {firstId} for window {WindowCtx.Id}", "cyan");

        var messages = await Channel.GetMessagesAsync(firstId, 64);

        if (messages is null || !messages.Any())
            return;

        // Step 1: Insert older messages above and fix scroll position.
        // ScaleScrollPosition only works correctly when content changes
        // happen on one side, so we must NOT trim in the same render pass.
        await UpdateScrollPosition();
        InsertMessages(0, messages); // renders
        await ScaleScrollPosition();

        // Step 2: Trim from the bottom if we exceed the cap.
        // Removed content is below the viewport so scroll is unaffected.
        if (DisplayedMessages.Count > TrimThreshold)
        {
            var excess = DisplayedMessages.Count - TargetMessages;
            DisplayedMessages.RemoveRange(DisplayedMessages.Count - excess, excess);
            _isCaughtUp = false;
            ReRender();
        }
    }
    
    ///////////////////////////////
    // Window State & Management //
    ///////////////////////////////
    
    public class StateData
    {
        public long? PlanetId { get; set; }
        public long ChannelId { get; set; }
    }

    public class Content : WindowContent<ChatWindowComponent, Channel>
    {
        /// <summary>
        /// When set, the chat will load around this message and highlight it
        /// </summary>
        public long? TargetMessageId { get; set; }

        public override async Task ImportData(string data, ValourClient client)
        {
            var imported = JsonSerializer.Deserialize<StateData>(data);

            if (imported.PlanetId is not null)
            {
                var planet = await client.PlanetService.FetchPlanetAsync(imported.PlanetId!.Value);
                await planet.EnsureReadyAsync();
                Data = await planet.FetchChannelAsync(imported.ChannelId);
            }
            else
            {
                Data = await client.ChannelService.FetchDirectChannelAsync(imported.ChannelId);
            }
        }

        public override string ExportData(ValourClient clientc)
        {
            if (Data is null)
                return null;
            
            var export = new StateData
            {
                PlanetId = Data.PlanetId,
                ChannelId = Data.Id
            };
            
            return JsonSerializer.Serialize(export);
        }
    }

    public static async Task<Content> GetContentForPlanetPrimaryChannel(Planet planet)
    {
        // Ensure planet node is ready
        await planet.EnsureReadyAsync();
        
        // get primary channel
        var channel = await planet.FetchPrimaryChatChannelAsync();
        
        return new()
        {
            Icon = await channel.GetIconAsync(),
            Title = await channel.GetTitleAsync(),
            PlanetId = planet.Id,
            Data = channel
        };
    }
    
    public static async Task<Content> GetDefaultContent(Channel channel)
    {
        if (channel.PlanetId is not null)
        {
            // Make sure planet is loaded for channel
            var planet = await channel.Client.PlanetService.FetchPlanetAsync(channel.PlanetId!.Value);
            await planet.EnsureReadyAsync();
        }

        return new()
        {
            Icon = await channel.GetIconAsync(),
            Title = await channel.GetTitleAsync(),
            PlanetId = channel.PlanetId,
            Data = channel
        };
    }
    
    ///////////////
    // Reconnect //
    ///////////////
    
    public async Task OnNodeReconnect(Node node)
    {
        await InvokeAsync(async () =>
        {
            if (Channel.PlanetId is null)
            {
                if (node.Name == Client.PrimaryNode.Name)
                {
                    await RecoverMissedMessages();
                }
            }
            else
            {
                if (node.Name == Channel.Planet.NodeName)
                {
                    await RecoverMissedMessages();
                }
            }
        });
    }

    private DateTime _lastRecoverAttempt = DateTime.MinValue;
    private bool _recoveringMessages;

    private async Task OnBrowserFocused()
    {
        await InvokeAsync(async () =>
        {
            if (Channel?.PlanetId is not null && Channel.ChannelType == ChannelTypeEnum.PlanetChat)
            {
                try
                {
                    var joinResult = await Channel.ConnectToRealtime();
                    if (!joinResult.Success)
                    {
                        Client.Logger.Log<ChatWindowComponent>(
                            $"Channel rejoin check failed for {Channel.Id}: {joinResult.Message}", "yellow");
                    }
                }
                catch (Exception e)
                {
                    Client.Logger.Log<ChatWindowComponent>(
                        $"Channel rejoin check threw for {Channel?.Id}: {e.Message}", "yellow");
                }
            }

            await RecoverMissedMessages();
        });
    }

    private async Task RecoverMissedMessages()
    {
        if (_loading || Channel is null || _jsService is null || _recoveringMessages)
            return;

        // Avoid hammering the API when focus/reconnect events happen in a burst.
        if ((DateTime.UtcNow - _lastRecoverAttempt).TotalMilliseconds < 750)
            return;

        _lastRecoverAttempt = DateTime.UtcNow;
        _recoveringMessages = true;

        try
        {
            long maxDisplayedId = DisplayedMessages
                .Where(x => x.Id > 0 && x.Id < long.MaxValue)
                .Select(x => x.Id)
                .DefaultIfEmpty(0)
                .Max();

            var latest = await GetRecoveryCandidates(maxDisplayedId);
            if (latest.Count == 0)
                return;

            var toAdd = latest
                .Where(m => m.Id > maxDisplayedId)
                .OrderBy(m => m.Id)
                .ToList();

            if (toAdd.Count == 0)
                return;

            var atBottom = await _jsService.InvokeAsync<bool>("isAtBottom");
            await AddMessages(toAdd, render: false, scroll: false);

            await ReRender();

            if (atBottom)
                await ScrollToBottom();

            _isCaughtUp = true;
        }
        catch (Exception e)
        {
            Client.Logger.Log<ChatWindowComponent>($"Failed recovering missed messages: {e.Message}", "yellow");
        }
        finally
        {
            _recoveringMessages = false;
        }
    }

    private async Task<List<Message>> GetRecoveryCandidates(long maxDisplayedId)
    {
        var latest = await Channel.GetLastMessagesAsync(64);
        if (latest is null || latest.Count == 0)
            return [];

        if (maxDisplayedId == 0)
            return latest;

        var recovered = new List<Message>(latest);
        var earliestId = latest[0].Id;
        var rounds = 0;

        // Bridge larger gaps by walking backwards in batches.
        while (earliestId > maxDisplayedId + 1 && rounds < 12)
        {
            var older = await Channel.GetMessagesAsync(earliestId, 64);
            if (older is null || older.Count == 0)
                break;

            recovered.InsertRange(0, older);

            var newEarliest = older[0].Id;
            if (newEarliest >= earliestId)
                break;

            earliestId = newEarliest;
            rounds++;

            if (older.Any(x => x.Id <= maxDisplayedId))
                break;
        }

        return recovered;
    }
    
    public async Task NotifyMessageMouseEnter(MessageComponent message)
    {
        if (_hoverMenu is not null)
        {
            _hoverMenuMessage = message;
            
            var bounds = await BrowserUtils.GetElementBoundingRectAsync(_hoverMenu.OuterRef);
            var wrapperBounds = await BrowserUtils.GetElementBoundingRectAsync(MessageWrapperEl);
            
            var distances = await BrowserUtils.GetVerticalContainerDistanceAsync(message.OuterRef, MessageWrapperEl);
            _hoverMenuTop = (distances.TopDistance + (bounds.Height / 2) - (DeviceInfo.IsMobile ? 70 : 40)) + "px";
            
            _hoverMenuRight = (BrowserUtils.WindowDimensions.Width - wrapperBounds.Right + (bounds.Width / 2) - (DeviceInfo.IsMobile ? 24 : 0 )) + "px"; //(wrapperBounds.Right - wrapperBounds.Width) + "px";
        
            var visibleDistances = await BrowserUtils.GetVisibleVerticalContainerDistanceAsync(message.OuterRef, MessageWrapperEl);
            
            _hoverMenu.SetOptions(GetHoverMenuOptions());
            _hoverMenu.SetPosition(_hoverMenuTop, rightPx: _hoverMenuRight);
            _hoverMenu.SetVisible(true);
        }
    }
    
    public void OnMouseLeaveMessageArea()
    {
        _hoverMenu.SetVisible(false);
    }
    
    /////////////
    // Cleanup //
    /////////////
    
    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        Channel.MessageDeleted -= OnDeleteMessage;
        Channel.MessageReceived -= OnReceiveMessage;
        Channel.MessageEdited -= OnReceiveMessageEdit;
        
        WindowCtx.Tab.OnStartFloating -= OnStartFloating;
        Client.NodeService.NodeReconnected -= OnNodeReconnect;
        BrowserUtils.Focused -= OnBrowserFocused;
        
        if (Channel.PlanetId is not null)
        {
            Channel.Planet.Deleted -= OnPlanetDeleted;
            
            if (Channel.Planet.MyMember is not null)
                Channel.Planet.MyMember.Deleted -= OnSelfMemberDeleted;
        }
        
        await Channel.Close(WindowChannelKey);
        
        _thisRef.Dispose();

        if (_jsModule is not null)
        {
            await _jsModule.DisposeAsync();
        }
        
        if (_jsService is not null)
        {
            await _jsService.DisposeAsync();
        }
    }
}
