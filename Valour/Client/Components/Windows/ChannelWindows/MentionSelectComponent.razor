@inject IJSRuntime JsRuntime

@if (Visible)
{
    <div class="mention-select">
        @for (var i = 0; i < _matches.Count; i++)
        {
            var x = i;
            var match = _matches[i];
            switch (match.Item)
            {
                case PlanetRole role:
                    <MentionSelectRoleComponent @key="@role.Id" Index="x" Parent="this" Role="@role" Selected="(x == Selected)" />
                    break;
                case PlanetMember member:
                    <MentionSelectMemberComponent @key="member.Id" Index="x" Parent="this" Member="member" Selected="(x == Selected)" />
                    break;
                case User user:
                    <MentionSelectUserComponent @key="user.Id" Index="x" Parent="this" User="user" Selected="(x == Selected)" />
                    break;
                case Channel channel:
                    <MentionSelectChannelComponent @key="channel.Id" Index="x" Parent="this" Channel="channel" Selected="(x == Selected)" />
                    break;
                case EmojiClickEvent emoji:
                    <MentionSelectEmojiComponent @key="@match.Key" Index="x" Parent="this" Emoji="@emoji" Selected="(x == Selected)" />
                    break;
            }
        }
    </div>
}

@code {
    
    [Parameter]
    public ChatWindowComponent ChannelComponent { get; set; }

    public bool Visible { get; set; }

    public string Text { get; set; }

    public int Selected { get; set; }

    public char Mode { get; set; }

    private class MentionMatch
    {
        public string Key { get; set; }
        public object Item { get; set; }
    }

    private List<MentionMatch> _matches;
    
    private List<User> _users;

    protected override void OnInitialized()
    {
        _matches = new();
    }


    public async Task SetVisible(bool value, char mode = ' ')
    {
        Visible = value;

        if (!value)
        {
            Mode = ' ';
            Selected = 0;
            _matches.Clear();
            StateHasChanged();
            return;
        }

        // On made visible, fetch all needed data
        if (ChannelComponent.Channel.PlanetId is null)
        {
            _users = await ChannelComponent.Channel.GetChannelMemberUsersAsync();
        }

        // Set mode
        Mode = mode;
        Selected = 0;

        StateHasChanged();
    }

    public async Task<bool> Submit()
    {
        if (!Visible || _matches.Count == 0 || Selected < 0 || Selected >= _matches.Count)
            return false;

        var selected = _matches[Selected].Item;
        switch (selected)
        {
            case PlanetMember member:
                {
                    var tag = $"«@m-{member.Id}» ";
                    var text = "@" + member.Name;
                    var classList = "mention";
                    var styleList = $"color: {member.GetRoleColor()}";
                    await ChannelComponent.InputComponent.InjectElementAsync(tag, text, classList, styleList);
                    break;
                }
            case User user:
                {
                    var tag = $"«@u-{user.Id}» ";
                    var text = "@" + user.Name;
                    var classList = "mention";
                    var styleList = $"color: white";

                    await ChannelComponent.InputComponent.InjectElementAsync(tag, text, classList, styleList);
                    break;
                }
            case PlanetRole role:
                {
                    var tag = $"«@r-{role.Id}» ";
                    var text = "@" + role.Name;
                    var classList = "mention";
                    var styleList = $"color: {role.Color}";

                    await ChannelComponent.InputComponent.InjectElementAsync(tag, text, classList, styleList);
                    break;
                }
            case Channel channel:
                {
                    var tag = $"«@c-{channel.Id}» ";
                    var text = "#" + channel.Name;
                    var classlist = "channel-mention";

                    await ChannelComponent.InputComponent.InjectElementAsync(tag, text, classlist, "");
                    break;
                }
            case EmojiClickEvent emoji:
                {
                    await ChannelComponent.InputComponent.InjectEmojiForAutocompleteAsync(emoji);
                    break;
                }
        }

        await SetVisible(false);

        Selected = 0;
        return true;
    }

    public async Task SetText(string newText)
    {
        Text = newText.TrimStart(Mode).ToLowerInvariant();

        _matches.Clear();

        if (Mode == '@')
        {
            if (ChannelComponent.Channel.PlanetId is not null)
            {
                if (string.IsNullOrEmpty(Text))
                {
                    _matches.AddRange((await ChannelComponent.GetLastChatMembers(10))
                        .Select(x => new MentionMatch { Key = x.Id.ToString(), Item = x }));
                }
                else
                {
                    // Get members which may match
                    var members = ChannelComponent.Channel.Planet.Members.Where(x => x.Name.ToLower().Contains(Text))
                                     .OrderByDescending(x => x.Name.ToLower().StartsWith(Text))
                                     .ThenBy(x => x.Name.Length)
                                     .Take(10)
                                     .Select(x => new MentionMatch() { Key = x.Id.ToString(), Item = x });

                    _matches.AddRange(members);

                    var canMentionAll = false;
                    var myMember = ChannelComponent.Channel.Planet.MyMember;
                    if (myMember is not null)
                    {
                        if (myMember.HasPermission(PlanetPermissions.MentionAll))
                        {
                            canMentionAll = true;
                        }
                    }

                    var roleQuery = ChannelComponent.Channel.Planet.Roles.Where(x => x.Name.ToLower().Contains(Text));
                    if (!canMentionAll)
                        roleQuery = roleQuery.Where(x => x.AnyoneCanMention);

                    var roles =
                        roleQuery.OrderByDescending(x => x.Name.ToLower().StartsWith(Text))
                        .ThenBy(x => x.Name.Length)
                        .Take(5)
                        .Select(x => new MentionMatch() { Key = x.Id.ToString(), Item = x });

                    _matches.AddRange(roles);
                }
            }
            else
            {
                _matches.AddRange(_users.Where(x => x.Name.ToLower().Contains(Text))
                                                 .OrderByDescending(x => x.Name.ToLower().StartsWith(Text))
                                                 .ThenBy(x => x.Name.Length)
                                                 .Take(10)
                                                 .Select(x => new MentionMatch() { Key = x.Id.ToString(), Item = x }));
            }
        }
        else if (Mode == '#')
        {
            _matches.AddRange(ChannelComponent.Channel.Planet.Channels.Where(x => x.ChannelType == ChannelTypeEnum.PlanetChat && x.Name.ToLower().Contains(Text))
                             .OrderByDescending(x => x.Name.ToLower().StartsWith(Text))
                             .ThenBy(x => x.Name.Length)
                             .Take(10)
                             .Select(x => new MentionMatch() { Key = x.Id.ToString(), Item = x }));
        }
        else if (Mode == ':')
        {
            if (!string.IsNullOrWhiteSpace(Text))
            {
                // Native emoji source; custom emoji matches can be merged here later.
                var emojis = await ChannelComponent.InputComponent.SearchEmojisAsync(Text, 10);
                _matches.AddRange(emojis.Select(x => new MentionMatch()
                {
                    Key = x.Id ?? x.Unified ?? x.Native,
                    Item = x
                }));
            }
        }

        if (_matches.Count == 0)
        {
            Selected = 0;
        }
        else if (Selected < 0 || Selected >= _matches.Count)
        {
            Selected = 0;
        }

        StateHasChanged();
    }

    public void MoveSelect(int n)
    {
        if (_matches.Count == 0)
        {
            Selected = 0;
            return;
        }

        Selected += n;

        if (Selected > _matches.Count - 1)
        {
            Selected = 0;
        }
        else if (Selected < 0)
        {
            Selected = _matches.Count - 1;
        }

        StateHasChanged();
    }
}
