@inject ValourClient Client
@implements IAsyncDisposable

<RealtimeKitComponent @ref="_rtk" />

@if (ActiveChannel is not null)
{
    @if (DeviceInfo.IsMobile)
    {
        @InnerContent
    }
    else
    {
        <div class="drag-area">
            <SmoothDraggable StartX="500" StartY="200" FromRight="@true">
                @InnerContent
            </SmoothDraggable>
        </div>
    }
}

@code {
    [CascadingParameter]
    public ModalRoot? ModalRoot { get; set; }

    private RealtimeKitComponent? _rtk;
    private readonly SemaphoreSlim _joinLock = new(1, 1);
    private static readonly TimeSpan JoinTimeout = TimeSpan.FromSeconds(25);
    private static readonly TimeSpan LeaveTimeout = TimeSpan.FromSeconds(8);

    private bool _joined;
    private bool _connecting;

    private bool _audioEnabled = true;

    private string? _error;
    private bool _pendingParticipantAudioSync;
    private Dictionary<string, int> _participantVolumes = new();
    private List<VoiceParticipantState> _participants = new();
    private CancellationTokenSource? _participantRefreshLoopCts;
    private Task? _participantRefreshLoopTask;
    private int _participantRefreshInProgress;

    public static CallComponent? Instance { get; private set; }

    public Channel? ActiveChannel { get; private set; }

    private string StatusText => _connecting ? "Connecting" : _joined ? "Connected" : "Disconnected";
    private string StatusBadgeClass => _connecting ? "connecting" : _joined ? "connected" : "disconnected";

    private int GetParticipantVolume(string peerId) =>
        _participantVolumes.TryGetValue(peerId, out var vol) ? vol : 100;

    private static string GetVolumeIcon(int volume) => volume switch
    {
        0 => "bi-volume-mute-fill",
        <= 50 => "bi-volume-down-fill",
        _ => "bi-volume-up-fill"
    };

    private RenderFragment InnerContent =>
        @<div class="call-container">
            <div class="call-header">
                <div class="call-header-info">
                    <span class="call-channel-name">@ActiveChannel!.Name</span>
                </div>
                <div class="call-status-badge @StatusBadgeClass">
                    <span class="call-status-dot"></span>
                    <span>@StatusText</span>
                </div>
            </div>

            <div class="call-controls">
                @if (!_joined)
                {
                    <button class="call-ctrl-btn reconnect" disabled="@_connecting" @onmousedown="OnClickReconnect" title="Connect">
                        <i class="bi bi-arrow-clockwise"></i>
                    </button>
                }
                else
                {
                    <button class="call-ctrl-btn @(_audioEnabled ? "" : "toggled-danger")" @onmousedown="OnClickMute" title="@(_audioEnabled ? "Mute" : "Unmute")">
                        <i class="bi @(_audioEnabled ? "bi-mic-fill" : "bi-mic-mute-fill")"></i>
                    </button>
                }

                <button class="call-ctrl-btn" @onmousedown="OnClickSettings" title="Settings">
                    <i class="bi bi-gear-fill"></i>
                </button>

                <button class="call-ctrl-btn danger" @onmousedown="OnClickLeave" title="Leave Call">
                    <i class="bi bi-box-arrow-right"></i>
                </button>
            </div>

            @if (_joined)
            {
                <div class="call-participants">
                    <div class="call-participants-header">
                        <span class="call-participants-label">Participants</span>
                        <span class="call-participants-count">@_participants.Count</span>
                    </div>

                    @if (_participants.Count == 0)
                    {
                        <p class="call-participants-empty">No one else is here yet.</p>
                    }
                    else
                    {
                        @foreach (var participant in _participants)
                        {
                            <div class="@GetParticipantClass(participant)" @key="participant.PeerId">
                                <div class="participant-info">
                                    <UserInfoComponent UserId="@participant.UserId" Style="width: 100%;" />
                                </div>
                                @if (participant.IsSelf)
                                {
                                    @if (!_audioEnabled)
                                    {
                                        <span class="participant-self-muted" title="You are muted">
                                            <i class="bi bi-mic-mute-fill"></i>
                                        </span>
                                    }
                                }
                                else
                                {
                                    var peerId = participant.PeerId;
                                    var volume = GetParticipantVolume(peerId);
                                    <div class="participant-volume">
                                        <input type="range" min="0" max="100"
                                               value="@volume"
                                               @oninput="(e) => OnParticipantVolumeChanged(peerId, e)"
                                               class="participant-volume-slider" />
                                        <button class="participant-volume-btn @(volume == 0 ? "muted" : "")"
                                                @onmousedown="() => ToggleParticipantMute(peerId)"
                                                title="@(volume == 0 ? "Unmute" : "Mute")">
                                            <i class="bi @GetVolumeIcon(volume)"></i>
                                        </button>
                                    </div>
                                }
                                <audio id="@GetParticipantAudioElementId(participant.PeerId)" class="participant-audio" autoplay playsinline></audio>
                            </div>
                        }
                    }
                </div>
            }

            @if (!string.IsNullOrWhiteSpace(_error))
            {
                <div class="call-error">
                    <i class="bi bi-exclamation-triangle-fill"></i>
                    <span>@_error</span>
                </div>
            }
        </div>;

    protected override void OnInitialized()
    {
        Instance = this;
        DevicePreferences.OnMicrophoneDeviceIdChanged += OnMicrophoneSelected;
    }

    public async Task Initialize(Channel channel)
    {
        if (!ISharedChannel.VoiceChannelTypes.Contains(channel.ChannelType))
            return;

        if (_rtk is null)
        {
            _error = "Voice system is still loading. Try again.";
            StateHasChanged();
            return;
        }

        await _joinLock.WaitAsync();

        try
        {
            _error = null;
            ActiveChannel = channel;
            _connecting = true;
            StateHasChanged();

            if (_joined)
            {
                await SafeLeaveRoomInternalAsync(closePanel: false);
            }

            var tokenResult = await Client.PrimaryNode.PostAsyncWithResponse<RealtimeKitVoiceTokenResponse>(
                $"api/voice/realtimekit/token/{channel.Id}");

            if (!tokenResult.Success || tokenResult.Data is null || string.IsNullOrWhiteSpace(tokenResult.Data.AuthToken))
            {
                _error = string.IsNullOrWhiteSpace(tokenResult.Message)
                    ? "Failed to fetch a voice token from the server."
                    : tokenResult.Message;
                _connecting = false;
                StateHasChanged();
                return;
            }

            await _rtk.InitializeAsync(new RealtimeKitInitOptions
            {
                AuthToken = tokenResult.Data.AuthToken,
                BaseUri = "realtime.cloudflare.com",
                Defaults = new RealtimeKitMediaDefaults
                {
                    Audio = false,
                    Video = false
                }
            });

            await _rtk.JoinRoomAsync((int)JoinTimeout.TotalMilliseconds);

            _joined = true;
            _connecting = false;

            // Attempt to enable microphone â€” not required to participate
            try
            {
                await _rtk.EnableAudioAsync();
                await SetMic(DevicePreferences.MicrophoneDeviceId);
            }
            catch
            {
                _audioEnabled = false;
            }

            await RefreshStateFromSdkAsync();
            await RefreshParticipantsAsync();
            StartParticipantRefreshLoop();
        }
        catch (Exception ex)
        {
            _error = GetExceptionMessage(ex, "Failed to connect to voice.");
            _connecting = false;
            await SafeLeaveRoomInternalAsync(closePanel: false);
        }
        finally
        {
            _joinLock.Release();
            StateHasChanged();
        }
    }

    private async Task RefreshStateFromSdkAsync()
    {
        if (_rtk is null || !_joined)
            return;

        var state = await _rtk.GetSelfStateAsync();
        if (state is null)
            return;

        _audioEnabled = state.AudioEnabled;
    }

    public async Task OnMicrophoneSelected(string id)
    {
        await SetMic(id);
    }

    private async Task OnClickReconnect()
    {
        if (ActiveChannel is null)
            return;

        await Initialize(ActiveChannel);
    }

    private async Task OnClickMute()
    {
        if (_rtk is null || !_joined)
            return;

        try
        {
            if (_audioEnabled)
            {
                await _rtk.DisableAudioAsync();
            }
            else
            {
                await _rtk.EnableAudioAsync();
            }

            await RefreshStateFromSdkAsync();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }

        StateHasChanged();
    }

    private void OnClickSettings()
    {
        if (ModalRoot is null)
            return;

        var data = new EditUserComponent.ModalParams
        {
            User = Client.Me,
            StartCategory = "General Settings",
            StartItem = "Device Preferences"
        };

        ModalRoot.OpenModal<EditUserComponent>(data);
    }

    private async Task OnClickLeave()
    {
        await LeaveRoom();
        StateHasChanged();
    }

    public async Task LeaveRoom()
    {
        await SafeLeaveRoomInternalAsync(closePanel: true);
    }

    private async Task SafeLeaveRoomInternalAsync(bool closePanel)
    {
        if (_rtk is not null)
        {
            try
            {
                if (_joined)
                {
                    await _rtk.LeaveRoomAsync().WaitAsync(LeaveTimeout);
                }
                else
                {
                    await _rtk.ResetAsync();
                }
            }
            catch
            {
                // Ignore leave failures during teardown.
            }
        }

        await StopParticipantRefreshLoopAsync();

        _joined = false;
        _connecting = false;
        _audioEnabled = true;
        _participantVolumes = new Dictionary<string, int>();
        _participants = new List<VoiceParticipantState>();
        _pendingParticipantAudioSync = false;

        if (closePanel)
        {
            ActiveChannel = null;
            _error = null;
        }
    }

    public async Task<InputMic[]> UpdateMics()
    {
        if (_rtk is null)
            return Array.Empty<InputMic>();

        var mics = await _rtk.GetAudioInputDevicesAsync();
        return mics
            .Where(x => !string.IsNullOrWhiteSpace(x.DeviceId))
            .Select((x, index) => new InputMic
            {
                DeviceId = x.DeviceId,
                Label = string.IsNullOrWhiteSpace(x.Label) ? $"Microphone {index + 1}" : x.Label
            })
            .ToArray();
    }

    public async Task<string> GetMicrophonePermissionStateAsync()
    {
        if (_rtk is null)
            return "unsupported";

        try
        {
            return await _rtk.GetMicrophonePermissionStateAsync();
        }
        catch
        {
            return "unknown";
        }
    }

    public async Task<bool> RequestMicrophonePermissionAsync()
    {
        if (_rtk is null)
            return false;

        try
        {
            return await _rtk.RequestMicrophonePermissionAsync();
        }
        catch
        {
            return false;
        }
    }

    public async Task SetMic(string? deviceId)
    {
        if (_rtk is null || !_joined || string.IsNullOrWhiteSpace(deviceId))
            return;

        try
        {
            await _rtk.SetDeviceAsync(new RealtimeKitDeviceSelection
            {
                DeviceId = deviceId,
                Kind = "audioinput"
            });

            await RefreshStateFromSdkAsync();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_pendingParticipantAudioSync || !_joined || _rtk is null)
            return;

        _pendingParticipantAudioSync = false;

        try
        {
            await SyncParticipantAudioElementsAsync();
        }
        catch (Exception ex)
        {
            _error = GetExceptionMessage(ex, "Failed to sync participant audio.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SyncParticipantAudioElementsAsync()
    {
        if (_rtk is null)
            return;

        foreach (var participant in _participants)
        {
            if (string.IsNullOrWhiteSpace(participant.PeerId))
                continue;

            var volume = GetParticipantVolume(participant.PeerId) / 100.0;
            await _rtk.SyncParticipantAudioAsync(
                GetParticipantAudioElementId(participant.PeerId),
                participant.PeerId,
                volume);
        }
    }

    private Task ToggleParticipantMute(string peerId)
    {
        var current = GetParticipantVolume(peerId);
        _participantVolumes[peerId] = current == 0 ? 100 : 0;
        _pendingParticipantAudioSync = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnParticipantVolumeChanged(string peerId, ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var volume))
        {
            _participantVolumes[peerId] = Math.Clamp(volume, 0, 100);
            _pendingParticipantAudioSync = true;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    private async Task RefreshParticipantsAsync()
    {
        if (_rtk is null || !_joined)
            return;

        if (Interlocked.Exchange(ref _participantRefreshInProgress, 1) == 1)
            return;

        try
        {
            var snapshot = await _rtk.GetParticipantsSnapshotAsync();
            var nextParticipants = BuildParticipantState(snapshot);

            if (AreParticipantsEqual(_participants, nextParticipants))
                return;

            _participants = nextParticipants;
            _pendingParticipantAudioSync = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = GetExceptionMessage(ex, "Failed to refresh voice participants.");
        }
        finally
        {
            Interlocked.Exchange(ref _participantRefreshInProgress, 0);
        }
    }

    private void StartParticipantRefreshLoop()
    {
        if (_participantRefreshLoopTask is { IsCompleted: false })
            return;

        _participantRefreshLoopCts?.Dispose();
        _participantRefreshLoopCts = new CancellationTokenSource();
        var cancellationToken = _participantRefreshLoopCts.Token;

        _participantRefreshLoopTask = Task.Run(async () =>
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    await RefreshParticipantsAsync();
                    await Task.Delay(350, cancellationToken);
                }
                catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
                {
                    break;
                }
                catch
                {
                    // Keep the participant refresh loop alive across transient SDK failures.
                }
            }
        }, cancellationToken);
    }

    private async Task StopParticipantRefreshLoopAsync()
    {
        if (_participantRefreshLoopCts is null)
            return;

        var cts = _participantRefreshLoopCts;
        var refreshTask = _participantRefreshLoopTask;

        _participantRefreshLoopCts = null;
        _participantRefreshLoopTask = null;

        try
        {
            cts.Cancel();
            if (refreshTask is not null)
            {
                await refreshTask;
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when stopping the refresh loop.
        }
        finally
        {
            cts.Dispose();
        }
    }

    private static string GetParticipantClass(VoiceParticipantState participant)
    {
        return participant.IsActiveSpeaker
            ? "voice-participant active-speaker"
            : "voice-participant";
    }

    private static string GetParticipantAudioElementId(string peerId)
    {
        var normalizedPeerId = string.IsNullOrWhiteSpace(peerId) ? "unknown" : peerId;
        var idBytes = System.Text.Encoding.UTF8.GetBytes(normalizedPeerId);
        var idSuffix = Convert.ToHexString(idBytes).ToLowerInvariant();
        return $"voice-audio-{idSuffix}";
    }

    private List<VoiceParticipantState> BuildParticipantState(RealtimeKitParticipantsSnapshot? snapshot)
    {
        if (snapshot?.Participants is null || snapshot.Participants.Length == 0)
            return new List<VoiceParticipantState>();

        var activeSpeakerPeerId = snapshot.ActiveSpeakerPeerId;

        return snapshot.Participants
            .Where(x => !string.IsNullOrWhiteSpace(x.PeerId))
            .Select(x => new VoiceParticipantState
            {
                PeerId = x.PeerId!,
                UserId = ResolveUserId(x),
                DisplayName = string.IsNullOrWhiteSpace(x.Name) ? "Unknown Participant" : x.Name,
                AudioEnabled = x.AudioEnabled,
                HasAudioTrack = x.HasAudioTrack,
                AudioTrackId = x.AudioTrackId,
                IsSelf = x.IsSelf,
                IsActiveSpeaker = string.Equals(x.PeerId, activeSpeakerPeerId, StringComparison.Ordinal)
            })
            .OrderByDescending(x => x.IsSelf)
            .ThenBy(x => x.DisplayName, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static long ResolveUserId(RealtimeKitParticipantState participant)
    {
        if (TryParseUserId(participant.CustomParticipantId, out var customId))
            return customId;

        if (long.TryParse(participant.UserId, out var userId) && userId > 0)
            return userId;

        return 0;
    }

    private static bool TryParseUserId(string? source, out long userId)
    {
        userId = 0;
        if (string.IsNullOrWhiteSpace(source))
            return false;

        var delimiterIndex = source.IndexOf(':');
        var candidate = delimiterIndex > 0 ? source[..delimiterIndex] : source;
        return long.TryParse(candidate, out userId) && userId > 0;
    }

    private static bool AreParticipantsEqual(IReadOnlyList<VoiceParticipantState> current, IReadOnlyList<VoiceParticipantState> next)
    {
        if (current.Count != next.Count)
            return false;

        for (int i = 0; i < current.Count; i++)
        {
            var left = current[i];
            var right = next[i];

            if (!string.Equals(left.PeerId, right.PeerId, StringComparison.Ordinal))
                return false;

            if (left.UserId != right.UserId)
                return false;

            if (!string.Equals(left.DisplayName, right.DisplayName, StringComparison.Ordinal))
                return false;

            if (left.AudioEnabled != right.AudioEnabled
                || left.HasAudioTrack != right.HasAudioTrack
                || !string.Equals(left.AudioTrackId, right.AudioTrackId, StringComparison.Ordinal)
                || left.IsSelf != right.IsSelf
                || left.IsActiveSpeaker != right.IsActiveSpeaker)
            {
                return false;
            }
        }

        return true;
    }

    private sealed class VoiceParticipantState
    {
        public string PeerId { get; init; } = string.Empty;

        public long UserId { get; init; }

        public string DisplayName { get; init; } = "Unknown Participant";

        public bool AudioEnabled { get; init; }

        public bool HasAudioTrack { get; init; }

        public string? AudioTrackId { get; init; }

        public bool IsSelf { get; init; }

        public bool IsActiveSpeaker { get; init; }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        DevicePreferences.OnMicrophoneDeviceIdChanged -= OnMicrophoneSelected;
        if (ReferenceEquals(Instance, this))
        {
            Instance = null;
        }

        await SafeLeaveRoomInternalAsync(closePanel: true);
    }

    private static string GetExceptionMessage(Exception exception, string fallbackMessage)
    {
        if (!string.IsNullOrWhiteSpace(exception.Message))
            return exception.Message;

        if (exception.InnerException is not null && !string.IsNullOrWhiteSpace(exception.InnerException.Message))
            return exception.InnerException.Message;

        return fallbackMessage;
    }
}
